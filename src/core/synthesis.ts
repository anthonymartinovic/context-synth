import { CSConfig, Chunk, SynthesisResult, Group, TemplateHeading, FilledSlot, ChunkAssignment, compareChunks } from "./types";
import { getRoutableSlots } from "./template";

// ---------------------------------------------------------------------------
// Synthesis core
// ---------------------------------------------------------------------------

export function synthesizeWithAssignments(
  template: TemplateHeading[],
  chunks: Chunk[],
  assignments: ChunkAssignment[]
): SynthesisResult {
  const eligible = chunks.filter((c) => c.sourceWeight > 0 && c.content.trim().length > 0);
  const slotIds = new Set(getRoutableSlots(template).map((s) => s.slotId));

  const byChunkId = new Map(assignments.map((a) => [a.chunkId, a.slotId]));
  const chunksBySlot = new Map<string, Chunk[]>();

  for (const chunk of eligible) {
    const slot = byChunkId.get(chunk.chunkId);
    if (!slot || !slotIds.has(slot)) continue;
    if (!chunksBySlot.has(slot)) chunksBySlot.set(slot, []);
    chunksBySlot.get(slot)!.push(chunk);
  }

  for (const group of chunksBySlot.values()) {
    group.sort(compareChunks);
  }

  const claimedHeadings = new Set<string>();

  const slots: FilledSlot[] = template.map((slot) => {
    claimedHeadings.add(slot.heading);

    if (slot.level === 1) {
      return { heading: slot.heading, level: slot.level, primary: null, supplementary: [] };
    }

    const matched = chunksBySlot.get(slot.slotId!) ?? [];
    if (matched.length === 0) {
      return { heading: slot.heading, level: slot.level, primary: null, supplementary: [] };
    }

    const [primary, ...supplementary] = matched;
    return { heading: slot.heading, level: slot.level, primary, supplementary };
  });

  const assignedChunkIds = new Set(assignments.map((a) => a.chunkId));
  const orphans = eligible.filter((c) => !assignedChunkIds.has(c.chunkId));

  return { slots, orphans };
}

// ---------------------------------------------------------------------------
// Emission (rendering to markdown)
// ---------------------------------------------------------------------------

export function renderSynthesized(
  result: SynthesisResult,
  cfg: CSConfig
): string {
  const lines: string[] = [];
  lines.push("# Synthesized Context");
  lines.push("");
  lines.push("_Generated by context-synth v0.1_");
  lines.push("");

  for (const slot of result.slots) {
    const hashes = "#".repeat(slot.level);

    if (slot.level === 1) {
      lines.push(`${hashes} ${slot.heading}`);
      lines.push("");
      continue;
    }

    lines.push(`${hashes} ${slot.heading}`);
    lines.push("");

    if (!slot.primary) {
      // Keep the template skeleton stable even when no content routes here.
      continue;
    }

    if (slot.primary) {
      lines.push(...renderChunkWithCitation(slot.primary, cfg));
      lines.push("");
    }

    for (const chunk of slot.supplementary) {
      lines.push(...renderChunkWithCitation(chunk, cfg, true));
      lines.push("");
    }
  }

  const orphans = result.orphans.filter((c) => shouldIncludeOrphan(c));
  if (orphans.length > 0) {
    lines.push("# Uncategorized");
    lines.push("");
    lines.push("_The following content did not match any template section._");
    lines.push("");

    for (const orphan of orphans) {
      lines.push(`## ${orphan.heading}`);
      lines.push("");
      lines.push(...renderChunkWithCitation(orphan, cfg));
      lines.push("");
    }
  }

  return lines.join("\n");
}

function shouldIncludeOrphan(chunk: Chunk): boolean {
  const words = chunk.content.trim().split(/\s+/).filter(Boolean).length;
  if (words === 0) return false;
  const minAt0 = 120;
  const minAt1 = 20;
  const w = Math.max(0, Math.min(1, chunk.sourceWeight));
  const threshold = Math.round(minAt0 + (minAt1 - minAt0) * w);
  return words >= threshold;
}

function renderChunkWithCitation(chunk: Chunk, cfg: CSConfig, isSupplementary: boolean = false): string[] {
  const lines: string[] = [];
  if (chunk.content.trim().length === 0) return lines;

  if (isSupplementary) {
    const quoted = chunk.content
      .split("\n")
      .map((line) => `> ${line}`)
      .join("\n");
    lines.push(`> **Additional context** from \`${chunk.filePath}\` (source: \`${chunk.sourceId}\`, weight: ${formatWeight(chunk.sourceWeight)}):`);
    lines.push(">");
    lines.push(quoted);
  } else {
    lines.push(chunk.content);
  }

  if (cfg.emit?.citations) {
    lines.push("");
    lines.push(formatCitation(chunk));
  }
  return lines;
}

function formatCitation(chunk: Chunk): string {
  const w = formatWeight(chunk.sourceWeight);
  return [
    "**Sources**",
    `- \`${chunk.filePath}\` (source: \`${chunk.sourceId}\`, weight: ${w})`,
  ].join("\n");
}

function formatWeight(w: number): string {
  return parseFloat(w.toFixed(3)).toString();
}
